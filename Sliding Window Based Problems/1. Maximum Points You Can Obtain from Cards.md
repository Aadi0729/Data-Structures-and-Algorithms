**Key Idea**

Instead of picking ```k``` cards from the ends, we exclude ```n - k``` contiguous cards from the middle.
Maximizing picked score = Total sum − Minimum subarray sum of length ```n - k```.

**Sliding Window Type**

*Fixed Window*

- Window size is known in advance: n - k
- Window slides one step at a time
- No dynamic expand/shrink decisions

**Window Validity**

A window is valid if its size is exactly ```n - k```.

**Window Movement**

- Initialize window with first ```n - k``` elements
- On each slide:
  - Remove left element
  - Add next right element
- Track the minimum window sum

**Complexity**

- Time: ```O(n)``` — each element enters and leaves the window once
- Space: ```O(1)``` — constant extra space

```
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size();

        long long totalSum = 0;
        for(auto val : cardPoints)
            totalSum += val;

        if(k == n)
            return totalSum;
        
        int left = 0;
        int right = n-k-1;

        long long winSum = 0;
        int i = left;
        while(i <= right)
            winSum += cardPoints[i++];
        
        int minWindowSum = winSum;

        while(right != n-1) {
            winSum = winSum - cardPoints[left++] + cardPoints[++right];

            minWindowSum = min(minWindowSum, winSum);
        }

        return totalSum - minWindowSum;
    }
};
```
