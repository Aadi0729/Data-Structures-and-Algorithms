The task is to find the maximum length contiguous substring that contains at most K distinct characters.

This is a natural extension of the Fruit Into Baskets problem, where the limit of distinct elements was fixed (2).
Here, the limit becomes configurable (K).

**Sliding Window Type**

*Variable Size Window*

- Window size is not fixed
- It expands greedily
- Shrinks only when the constraint is violated

**Window Validity**

A window is valid if:
```
Number of distinct characters ≤ K
```

This is tracked using a frequency map, where:

- Keys → characters
- Values → frequency inside the current window

```
class Solution {
public:
    int kDistinctChar(string& s, int k) {
        int n = s.size();

        unordered_map<char, int> freqMap;

        int left = 0;
        int right = 0;

        int maxLen = 0;

        while(right < n) {
            freqMap[s[right]]++;

            if(freqMap.size() <= k) {
                maxLen = max(maxLen, right-left+1);
                right++;
            }
            else {
                while(freqMap.size() > k) {
                    freqMap[s[left]]--;

                    if(freqMap[s[left]] == 0)
                        freqMap.erase(s[left]);
                    
                    left++;
                }
                maxLen = max(maxLen, right-left+1);
                right++;
            }
        }
        return maxLen;
    }
}
```

**Pattern Takeaway**

- This problem generalizes “At Most 2 Distinct” → “At Most K Distinct”
- Validity depends on map size, not individual frequencies
- Reinforces the core variable sliding window template

**Complexity Analysis**

Time Complexity: ```O(n)```
Each character enters and leaves the window once.

Space Complexity: ```O(K)```
The frequency map stores at most K distinct characters.
