**Problem Insight**

The task is to find the *longest contiguous subarray* that contains *at most 2 distinct elements*.
This naturally fits a *variable-size sliding window* pattern.

**Core Idea**

Maintain a sliding window using two pointers and a *frequency map* to track how many times each fruit type appears in the current window.
- Expand the window by moving the right pointer.
- If the number of distinct fruit types exceeds 2, shrink the window from the left.
- Remove a fruit type from the map *only when its frequency becomes 0*.
- Track the maximum window size whenever the window is valid.

**Window Validity**

A window is valid if it contains *at most 2 distinct fruit types*
(i.e., ```freqMap.size() ≤ 2```).

**Algorithm Steps**

1. Initialize two pointers ```left = 0```, ```right = 0```.

2. Use a hash map to store frequencies of fruits in the window.

3. Expand the window by including ```fruits[right]```.

4. While the window becomes invalid (```distinct > 2```), shrink from the left:
   - Decrease frequency.
   - Remove key if frequency becomes 0.

5. Update the maximum window length.

6. Repeat until the end of the array.

```
#include <bits/stdc++.h>
using namespace std;

int totalFruits(vector<int>& fruits) {
    int n = fruits.size();

    unordered_map<int, int> freqMap;

    int maxLen = 0;

    int left = 0;
    int right = 0;
    while(right < n) {
        freqMap[fruits[right]]++;

        if(freqMap.size() <= 2) {
            maxLen = max(maxLen, right-left+1);
            right++;
        }
        else {
            while(freqMap.size() > 2) {
                freqMap[fruits[left]]--;
                if(freqMap[fruits[left]] == 0)
                    freqMap.erase(fruits[left]);
                left++;
            }
            maxLen = max(maxLen, right-left+1);
            right++;
        }
    }
    return maxLen;
}

int main() {
    #ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
    #endif

    int n;
    cin >> n;

    vector<int> fruits(n);

    for(int i=0; i<n; i++) {
        cin >> fruits[i];
    }

    cout << "There are " << totalFruits(fruits) << " fruits that can be picked.";

    return 0;
}
```

**Complexity**
**Time:** ```O(n)``` — each element enters and leaves the window once

**Space:** ```O(1)``` — at most 2 keys in the frequency map

**Pattern**

This problem demonstrates how *variable sliding window* works with:

- Dynamic window size
- Constraint-based shrinking
- Frequency tracking for correctness
