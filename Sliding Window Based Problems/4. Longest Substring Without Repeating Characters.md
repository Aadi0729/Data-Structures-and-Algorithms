Pattern: Sliding Window (Variable Size)

ğŸ§  Problem Insight

The goal is to find the length of the longest contiguous substring in which no character repeats.

This is a sliding window problem where:

Duplicates are not allowed

The window must maintain unique characters only

ğŸªŸ Sliding Window Type

Variable Size Window

Window expands greedily

Shrinks immediately when invalid

No fixed size

âœ… Window Validity

A window is valid if:

No character appears more than once


In other words:

freq[char] â‰¤ 1 for all characters

ğŸ”„ Window Movement Logic

Expand the window by moving the right pointer.

Add the current character to a frequency map.

If any character frequency becomes greater than 1:

Shrink from the left

Decrease frequency

Continue shrinking until all frequencies â‰¤ 1

Update maximum window length when valid.

```
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();

        unordered_map<char, int> freqMap;

        int left = 0;
        int right = 0;

        int maxLen = 0;

        while(right < n) {
            freqMap[s[right]]++;

            while(freqMap[s[right]] > 1) {
                freqMap[s[left]]--;

                if(freqMap[s[left]] == 0)
                    freqMap.erase(s[left]);
                    
                    left++;
                }
                maxLen = max(maxLen, right-left+1);
                right++;
        }
        return maxLen;
    }
};
```

â±ï¸ Complexity Analysis

Time Complexity: O(n)
Each character enters and leaves the window once.

Space Complexity: O(min(n, charset))
Depends on the number of unique characters.

ğŸ“Œ Pattern Takeaway

Validity depends on frequency values, not map size.

This is stricter than â€œAt Most K Distinctâ€.

Teaches how to maintain strict uniqueness in a window.

Core template remains unchanged â€” only validity rule differs.

ğŸ”‘ Key Learning

Sliding window structure stays the same.
Only the validity condition changes from problem to problem.
